"""
This type stub file was generated by pyright.
"""

import numpy as np
import pyvips
from typing import Any, List, Tuple, Type, TypeVar

T = TypeVar("T")

class ImageType(type):
    def __getattr__(cls, name: str) -> Any:
        ...

class Image(pyvips.VipsObject):
    """Wrap a VipsImage object.

    """
    __slots__: Tuple[str] = ...
    def __init__(self, pointer) -> None:
        ...
    
    @staticmethod
    def new_from_file(vips_filename, **kwargs): # -> list[Unknown] | None:
        """Load an image from a file.

        This method can load images in any format supported by vips. The
        filename can include load options, for example::

            image = pyvips.Image.new_from_file('fred.jpg[shrink=2]')

        You can also supply options as keyword arguments, for example::

            image = pyvips.Image.new_from_file('fred.jpg', shrink=2)

        The full set of options available depend upon the load operation that
        will be executed. Try something like::

            $ vips jpegload

        at the command-line to see a summary of the available options for the
        JPEG loader.

        Loading is fast: only enough of the image is loaded to be able to fill
        out the header. Pixels will only be decompressed when they are needed.

        Args:
            vips_filename (str): The disc file to load the image from, with
                optional appended arguments.

        All loaders support at least the following options:

        Keyword args:
            memory (bool): If set True, load the image via memory rather than
                via a temporary disc file. See :meth:`.new_temp_file` for
                notes on where temporary files are created. Small images are
                loaded via memory by default, use ``VIPS_DISC_THRESHOLD`` to
                set the definition of small.
            access (Access): Hint the expected access pattern for the image.
            fail (bool): If set True, the loader will fail with an error on
                the first serious error in the file. By default, libvips
                will attempt to read everything it can from a damaged image.

        Returns:
            A new :class:`.Image`.

        Raises:
            :class:`.Error`

        """
        ...
    
    @staticmethod
    def new_from_buffer(data, options, **kwargs): # -> list[Unknown] | None:
        """Load a formatted image from memory.

        This behaves exactly as :meth:`new_from_file`, but the image is
        loaded from the memory object rather than from a file. The memory
        object can be anything that supports the Python buffer protocol.

        Args:
            data (array, bytearray, bytes, buffer): The memory object to
                load the image from.
            options (str): Load options as a string. Use ``""`` for no options.

        All loaders support at least the following options:

        Keyword args:
            access (Access): Hint the expected access pattern for the image.
            fail (bool): If set True, the loader will fail with an error on the
                first serious error in the image. By default, libvips will
                attempt to read everything it can from a damaged image.

        Returns:
            A new :class:`Image`.

        Raises:
            :class:`.Error`

        """
        ...
    
    @staticmethod
    def new_from_list(array, scale=..., offset=...): # -> Image:
        """Create an image from a list or list of lists.

        A new one-band image with :class:`BandFormat` ``'double'`` pixels is
        created from the array. These image are useful with the libvips
        convolution operator :meth:`Image.conv`.

        Args:
            array (list[list[float]]): Create the image from these values.
                1D arrays become a single row of pixels.
            scale (float): Default to 1.0. What to divide each pixel by after
                convolution.  Useful for integer convolution masks.
            offset (float): Default to 0.0. What to subtract from each pixel
                after convolution.  Useful for integer convolution masks.

        Returns:
            A new :class:`Image`.

        Raises:
            :class:`.Error`

        """
        ...
    
    @classmethod
    def new_from_array(cls, obj: List[List[float]] | np.ndarray[float, np.dtype[np.uint8]], scale: float=..., offset: float=..., interpretation: str=...) -> Image:
        """Create a new Image from a list or an array-like object.

        Array-like objects are those which define `__array_interface__` or
        `__array__`. For details about the array interface, see `The Array
        Interface
        <https://numpy.org/doc/stable/reference/arrays.interface.html>`_.

        If `__array_interface__` is not available, `__array__` is used as a
        fallback.

        The behavior for input objects with different dimensions is summarized
        as::

            | array ndim | array shape | Image w | Image h | Image bands |
            |------------|-------------|---------|---------|-------------|
            | 0          | ()          | 1       | 1       | 1           |
            | 1          | (W,)        | W       | 1       | 1           |
            | 2          | (H, W)      | W       | H       | 1           |
            | 3          | (H, W, C)   | W       | H       | C           |


        Args:
            obj (list or object width `__array_interface__` or `__array__`):
                The object to convert to an image.

                If the input object is a list, `Image.new_from_list` is used
                with the given `scale` and `offset`

                If the input object is an array-like object, a new image is
                created from the object's data and shape.  The memory is shared
                except in the following cases:

                - The object's memory is not contiguous.  In this case, a copy
                  is made by attempting to call the object's `tobytes()` method
                  or its `tostring()` method.

                - The object is an array of bools, in which case it is
                  converted to a pyvips uchar image with True values becoming
                  255 and False values becoming 0.

            scale (float): Default to 1.0. **Ignored for non-list inputs**.
                What to divide each pixel by after convolution.  Useful for
                integer convolution masks.
            offset (float): Default to 0.0.  **Ignored for non-list inputs**.
                What to subtract from each pixel after convolution.  Useful for
                integer convolution masks.
            interpretation (str, optional): **Ignored for list inputs** The
                libvips interpretation of the array. If None, the
                interpretation defaults to the pyvips one for
                `Image.new_from_memory`.

                If 'auto', a heuristic is used to determine a best-guess
                interpretation as defined in the `_guess_interpretation`
                function.

                Must be one of None, 'auto', 'error', 'multiband', 'b-w',
                'histogram', 'xyz', 'lab', 'cmyk', 'labq', 'rgb', 'cmc', 'lch',
                'labs', 'srgb', 'yxy', 'fourier', 'rgb16', 'grey16', 'matrix',
                'scrgb', or 'hsv'

        Returns:
            The new image.

        See Also:
            :func:`_guess_interpretation`
        """
        ...
    
    @staticmethod
    def new_from_memory(data, width, height, bands, format): # -> Image:
        """Wrap an image around a memory array.

        Wraps an Image around an area of memory containing a C-style array. For
        example, if the ``data`` memory array contains four bytes with the
        values 1, 2, 3, 4, you can make a one-band, 2x2 uchar image from
        it like this::

            image = Image.new_from_memory(data, 2, 2, 1, 'uchar')

        A reference is kept to the data object, so it will not be
        garbage-collected until the returned image is garbage-collected.

        This method is useful for efficiently transferring images from PIL or
        NumPy into libvips.

        See :meth:`.write_to_memory` for the opposite operation.

        Use :meth:`.copy` to set other image attributes.

        Args:
            data (bytes): A memoryview or buffer object.
            width (int): Image width in pixels.
            height (int): Image height in pixels.
            bands (int): Number of bands.
            format (BandFormat): Band format.

        Returns:
            A new :class:`Image`.

        Raises:
            :class:`.Error`

        """
        ...
    
    @staticmethod
    def new_from_source(source, options, **kwargs): # -> list[Unknown] | None:
        """Load a formatted image from a source.

        This behaves exactly as :meth:`new_from_file`, but the image is
        loaded from the source rather than from a file.

        Args:
            source (Source): The source to load the image from.
            options (str): Load options as a string. Use ``""`` for no options.

        All loaders support at least the following options:

        Keyword args:
            access (Access): Hint the expected access pattern for the image.
            fail (bool): If set True, the loader will fail with an error on the
                first serious error in the image. By default, libvips will
                attempt to read everything it can from a damaged image.

        Returns:
            A new :class:`Image`.

        Raises:
            :class:`.Error`

        """
        ...
    
    @staticmethod
    def new_temp_file(format): # -> Image:
        """Make a new temporary image.

        Returns an image backed by a temporary file. When written to with
        :func:`Image.write`, a temporary file will be created on disc in the
        specified format. When the image is closed, the file will be deleted
        automatically.

        The file is created in the temporary directory. This is set with
        the environment variable ``TMPDIR``. If this is not set, then on
        Unix systems, vips will default to ``/tmp``. On Windows, vips uses
        ``GetTempPath()`` to find the temporary directory.

        vips uses ``g_mkstemp()`` to make the temporary filename. They
        generally look something like ``"vips-12-EJKJFGH.v"``.

        Args:
            format (str): The format for the temp file, for example
                ``"%s.v"`` for a vips format file. The ``%s`` is
                substituted by the file path.

        Returns:
            A new :class:`Image`.

        Raises:
            :class:`.Error`

        """
        ...
    
    def new_from_image(self, value):
        """Make a new image from an existing one.

        A new image is created which has the same size, format, interpretation
        and resolution as ``self``, but with every pixel set to ``value``.

        Args:
            value (float, list[float]): The value for the pixels. Use a
                single number to make a one-band image; use an array constant
                to make a many-band image.

        Returns:
            A new :class:`Image`.

        Raises:
            :class:`.Error`

        """
        ...
    
    def copy_memory(self): # -> Image:
        """Copy an image to memory.

        A large area of memory is allocated, the image is rendered to that
        memory area, and a new image is returned which wraps that large memory
        area.

        Returns:
            A new :class:`Image`.

        Raises:
            :class:`.Error`

        """
        ...
    
    def write_to_file(self, vips_filename: str, **kwargs: Any) -> None:
        """Write an image to a file on disc.

        This method can save images in any format supported by vips. The format
        is selected from the filename suffix. The filename can include embedded
        save options, see :func:`Image.new_from_file`.

        For example::

            image.write_to_file('fred.jpg[Q=95]')

        You can also supply options as keyword arguments, for example::

            image.write_to_file('fred.jpg', Q=95)

        The full set of options available depend upon the load operation that
        will be executed. Try something like::

            $ vips jpegsave

        at the command-line to see a summary of the available options for the
        JPEG saver.

        Args:
            vips_filename (str): The disc file to save the image to, with
                optional appended arguments.

        Other arguments depend upon the save operation.

        Returns:
            None

        Raises:
            :class:`.Error`

        """
        ...
    
    def write_to_buffer(self, format_string, **kwargs): # -> str | bool | Image | list[Unknown] | None:
        """Write an image to memory.

        This method can save images in any format supported by vips. The format
        is selected from the suffix in the format string. This can include
        embedded save options, see :func:`Image.write_to_file`.

        For example::

            data = image.write_to_buffer('.jpg[Q=95]')

        You can also supply options as keyword arguments, for example::

            data = image.write_to_buffer('.jpg', Q=95)

        The full set of options available depend upon the load operation that
        will be executed. Try something like::

            $ vips jpegsave_buffer

        at the command-line to see a summary of the available options for the
        JPEG saver.

        Args:
            format_string (str): The suffix, plus any string-form arguments.

        Other arguments depend upon the save operation.

        Returns:
            A byte string.

        Raises:
            :class:`.Error`

        """
        ...
    
    def write_to_target(self, target, format_string, **kwargs): # -> list[Unknown] | None:
        """Write an image to a target.

        This method will write the image to the target in the format
        specified in the suffix in the format string. This can include
        embedded save options, see :func:`Image.write_to_file`.

        For example::

            image.write_to_target(target, '.jpg[Q=95]')

        You can also supply options as keyword arguments, for example::

            image.write_to_target(target, '.jpg', Q=95)

        The full set of options available depend upon the save operation that
        will be executed. Try something like::

            $ vips jpegsave_target

        at the command-line to see a summary of the available options for the
        JPEG saver.

        Args:
            target (Target): The target to write the image to
            format_string (str): The suffix, plus any string-form arguments.

        Other arguments depend upon the save operation.

        Returns:
            None

        Raises:
            :class:`.Error`

        """
        ...
    
    def write_to_memory(self):
        """Write the image to a large memory array.

        A large area of memory is allocated, the image is rendered to that
        memory array, and the array is returned as a buffer.

        For example, if you have a 2x2 uchar image containing the bytes 1, 2,
        3, 4, read left-to-right, top-to-bottom, then::

            buf = image.write_to_memory()

        will return a four byte buffer containing the values 1, 2, 3, 4.

        Returns:
            buffer

        Raises:
            :class:`.Error`

        """
        ...
    
    def write(self, other): # -> None:
        """Write an image to another image.

        This function writes ``self`` to another image. Use something like
        :func:`Image.new_temp_file` to make an image that can be written to.

        Args:
            other (Image): The :class:`Image` to write to,

        Returns:
            None

        Raises:
            :class:`.Error`

        """
        ...
    
    def invalidate(self): # -> None:
        """Drop caches on an image, and any downstream images.

        This method drops all pixel caches on an image and on all downstream
        images. Any operations which depend on this image, directly or
        indirectly, are also dropped from the libvips operation cache.

        This method can be useful if you wrap a libvips image around an area
        of memory with :meth:`.new_from_memory` and then change some bytes
        without libvips knowing.

        Returns:
            None

        """
        ...
    
    def set_progress(self, progress): # -> None:
        """Enable progress reporting on an image.

        When progress reporting is enabled, evaluation of the most downstream
        image from this image will report progress using the ::preeval, ::eval,
        and ::posteval signals.

        """
        ...
    
    def set_kill(self, kill): # -> None:
        """Kill processing of an image.

        Use this to kill evaluation of an image. You can call it from one of
        the progress signals, for example. See :meth:`.set_progress`.

        """
        ...
    
    def get_typeof(self, name):
        """Get the GType of an item of metadata.

        Fetch the GType of a piece of metadata, or 0 if the named item does not
        exist. See :class:`GValue`.

        Args:
            name (str): The name of the piece of metadata to get the type of.

        Returns:
            The ``GType``, or 0.

        Raises:
            None

        """
        ...
    
    def get(self, name): # -> str | bool | Image | list[Unknown] | None:
        """Get an item of metadata.

        Fetches an item of metadata as a Python value. For example::

            orientation = image.get('orientation')

        would fetch the image orientation.

        Args:
            name (str): The name of the piece of metadata to get.

        Returns:
            The metadata item as a Python value.

        Raises:
            :class:`.Error`

        """
        ...
    
    def get_fields(self): # -> list[Unknown]:
        """Get a list of all the metadata fields on an image.

        Returns:
            [string]

        """
        ...
    
    def set_type(self, gtype, name, value): # -> None:
        """Set the type and value of an item of metadata.

        Sets the type and value of an item of metadata. Any old item of the
        same name is removed. See :class:`GValue` for types.

        Args:
            gtype (int): The GType of the metadata item to create.
            name (str): The name of the piece of metadata to create.
            value (mixed): The value to set as a Python value. It is
                converted to the ``gtype``, if possible.

        Returns:
            None

        Raises:
            None

        """
        ...
    
    def set(self, name, value): # -> None:
        """Set the value of an item of metadata.

        Sets the value of an item of metadata. The metadata item must already
        exist.

        Args:
            name (str): The name of the piece of metadata to set the value of.
            value (mixed): The value to set as a Python value. It is
                converted to the type of the metadata item, if possible.

        Returns:
            None

        Raises:
            :class:`.Error`

        """
        ...
    
    def remove(self, name):
        """Remove an item of metadata.

        The named metadata item is removed.

        Args:
            name (str): The name of the piece of metadata to remove.

        Returns:
            None

        Raises:
            None

        """
        ...
    
    def tolist(self): # -> list[list[Any]]:
        """Return a single-band image as a list of lists.

        Returns:
            list of lists of values

        """
        ...
    
    def __array__(self, dtype=...): # -> NDArray[Unknown] | ndarray[Any, dtype[Any]]:
        """Conversion to a NumPy array.

        Args:
            dtype (str or numpy dtype, optional) The dtype to use for the
                numpy array. If None, the default dtype of the image is used
                as defined the global `FORMAT_TO_TYPESTR` dictionary.

        Returns:
            numpy.ndarray: The array representation of the image.
                * Single-band images lose their channel axis.
                * Single-pixel single-band images are converted to a 0D array.

        See https://numpy.org/devdocs/user/basics.dispatch.html for more
        details.

        This enables a :class:`Image` to be used where a numpy array is
        expected, including in plotting and conversion to other array
        container types (pytorch, JAX, dask, etc.), for example.

        `numpy` is a runtime dependency of this function.

        See Also `Image.new_from_array` for the inverse operation. #TODO
        """
        ...
    
    def numpy(self, dtype=...): # -> NDArray[Unknown] | ndarray[Any, dtype[Any]]:
        """Convenience function to allow numpy conversion to be at the end
        of a method chain.

        This mimics the behavior of pytorch: ``arr = im.op1().op2().numpy()``

        numpy is a runtime dependency of this function.

        Args:
            dtype (str or numpy dtype): The dtype to use for the numpy array.
                If None, the default dtype of the image is used.

        Returns:
            numpy.ndarray: The image as a numpy array.

        See Also:

            - :meth:`.__array__`
            - `FORMAT_TO_TYPESTR`: Global dictionary mapping libvips format
              strings to numpy dtype strings.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __getattr__(self, name): # -> str | bool | Image | float | ((*args: Unknown, **kwargs: Unknown) -> (Unknown | list[Unknown] | None)) | list[Unknown] | None:
        """Divert unknown names to libvips.

        Unknown attributes are first looked up in the image properties as
        accessors, for example::

            width = image.width

        and then in the libvips operation table, where they become method
        calls, for example::

            new_image = image.invert()

        Use :func:`get` to fetch image metadata.

        A ``__getattr__`` on the metatype lets you call static members in the
        same way.

        Args:
            name (str): The name of the piece of metadata to get.

        Returns:
            Mixed.

        Raises:
            :class:`.Error`

        """
        ...
    
    @_deprecated('use Image.get() instead')
    def get_value(self, name): # -> str | bool | Image | list[Unknown] | None:
        ...
    
    @_deprecated('use Image.set() instead')
    def set_value(self, name, value): # -> None:
        ...
    
    @_deprecated('use Image.scale instead')
    def get_scale(self): # -> str | bool | Image | float | ((*args: Unknown, **kwargs: Unknown) -> (Unknown | list[Unknown] | None)) | list[Unknown] | None:
        ...
    
    @_deprecated('use Image.offset instead')
    def get_offset(self): # -> str | bool | Image | float | ((*args: Unknown, **kwargs: Unknown) -> (Unknown | list[Unknown] | None)) | list[Unknown] | None:
        ...
    
    def __enter__(self): # -> Self@Image:
        ...
    
    def __exit__(self, type, value, traceback): # -> None:
        ...
    
    def __getitem__(self, arg): # -> list[Unknown] | None:
        """Overload [] to pull out band elements from an image.

        The following arguments types are accepted:

        * int::

            green = rgb_image[1]

          Will make a new one-band image from band 1 (the middle band).

        * slice::

            last_two = rgb_image[1:]
            last_band = rgb_image[-1]
            middle_few = multiband[1:-2]
            reversed  = multiband[::-1]
            every_other = multiband[::2]
            other_every_other = multiband[1::2]

        * list of int::

            # list of integers
            desired_bands = [1, 2, 2, -1]
            four_band = multiband[desired_bands]

        * list of bool::

            wanted_bands = [True, False, True, True, False]
            three_band = five_band[wanted_bands]

        In the case of integer or slice arguments, the semantics of slicing
        exactly match those of slicing `range(self.bands)`.

        In the case of list arguments, the semantics match those of numpy's
        extended slicing syntax. Thus, lists of booleans must have as many
        elements as there are bands in the image.

        """
        ...
    
    def __call__(self, x, y): # -> list[Unknown] | None:
        """Fetch a pixel value.

        Args:
            x (int): The x coordinate to fetch.
            y (int): The y coordinate to fetch.

        Returns:
            Pixel as an array of floating point numbers.

        Raises:
            :class:`.Error`

        """
        ...
    
    def __add__(self, other): # -> list[Unknown] | None:
        ...
    
    def __radd__(self, other): # -> list[Unknown] | None:
        ...
    
    def __sub__(self, other): # -> list[Unknown] | None:
        ...
    
    def __rsub__(self, other): # -> list[Unknown] | None:
        ...
    
    def __mul__(self, other): # -> list[Unknown] | None:
        ...
    
    def __rmul__(self, other): # -> list[Unknown] | None:
        ...
    
    def __div__(self, other): # -> list[Unknown] | None:
        ...
    
    def __rdiv__(self, other):
        ...
    
    def __truediv__(self, other): # -> list[Unknown] | None:
        ...
    
    def __rtruediv__(self, other):
        ...
    
    def __floordiv__(self, other):
        ...
    
    def __rfloordiv__(self, other):
        ...
    
    def __mod__(self, other): # -> list[Unknown] | None:
        ...
    
    def __pow__(self, other): # -> list[Unknown] | None:
        ...
    
    def __rpow__(self, other): # -> list[Unknown] | None:
        ...
    
    def __abs__(self): # -> list[Unknown] | None:
        ...
    
    def __lshift__(self, other): # -> list[Unknown] | None:
        ...
    
    def __rshift__(self, other): # -> list[Unknown] | None:
        ...
    
    def __and__(self, other): # -> list[Unknown] | None:
        ...
    
    def __rand__(self, other): # -> list[Unknown] | None:
        ...
    
    def __or__(self, other): # -> list[Unknown] | None:
        ...
    
    def __ror__(self, other): # -> list[Unknown] | None:
        ...
    
    def __xor__(self, other): # -> list[Unknown] | None:
        ...
    
    def __rxor__(self, other): # -> list[Unknown] | None:
        ...
    
    def __neg__(self): # -> list[Unknown] | None:
        ...
    
    def __pos__(self): # -> Self@Image:
        ...
    
    def __invert__(self): # -> list[Unknown] | None:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def floor(self): # -> list[Unknown] | None:
        """Return the largest integral value not greater than the argument."""
        ...
    
    def ceil(self): # -> list[Unknown] | None:
        """Return the smallest integral value not less than the argument."""
        ...
    
    def rint(self): # -> list[Unknown] | None:
        """Return the nearest integral value."""
        ...
    
    def bandand(self): # -> list[Unknown] | None:
        """AND image bands together."""
        ...
    
    def bandor(self): # -> list[Unknown] | None:
        """OR image bands together."""
        ...
    
    def bandeor(self): # -> list[Unknown] | None:
        """EOR image bands together."""
        ...
    
    def bandsplit(self): # -> list[Unknown | list[Unknown] | None]:
        """Split an n-band image into n separate images."""
        ...
    
    def bandjoin(self, other): # -> Self@Image | list[Unknown] | None:
        """Append a set of images or constants bandwise."""
        ...
    
    def atan2(self, other): # -> list[Unknown] | None:
        ...
    
    def get_n_pages(self): # -> str | bool | Image | list[Unknown] | Literal[1] | None:
        """Get the number of pages in an image file, or 1.

        This is the number of pages in the file the image was loaded from, not
        the number of pages in the image.

        To get the number of pages in an image, divide the image height by
        the page height.
        """
        ...
    
    def get_page_height(self): # -> str | bool | Image | float | ((*args: Unknown, **kwargs: Unknown) -> (Unknown | list[Unknown] | None)) | list[Unknown] | None:
        """Get the page height in a many-page image, or height.
        """
        ...
    
    def pagesplit(self): # -> list[Unknown | list[Unknown] | None]:
        """Split an N-page image into a list of N separate images.
        """
        ...
    
    def pagejoin(self, other):
        """Join a set of pages vertically to make a multipage image.

        Also sets the page-height property on the result.
        """
        ...
    
    def composite(self, other, mode, **kwargs): # -> list[Unknown] | None:
        """Composite a set of images with a set of modes."""
        ...
    
    def bandrank(self, other, **kwargs): # -> list[Unknown] | None:
        """Band-wise rank filter a set of images."""
        ...
    
    def maxpos(self): # -> tuple[Unknown, Unknown, Unknown]:
        """Return the coordinates of the image maximum."""
        ...
    
    def minpos(self): # -> tuple[Unknown, Unknown, Unknown]:
        """Return the coordinates of the image minimum."""
        ...
    
    def real(self): # -> list[Unknown] | None:
        """Return the real part of a complex image."""
        ...
    
    def imag(self): # -> list[Unknown] | None:
        """Return the imaginary part of a complex image."""
        ...
    
    def polar(self):
        """Return an image converted to polar coordinates."""
        ...
    
    def rect(self):
        """Return an image converted to rectangular coordinates."""
        ...
    
    def conj(self): # -> list[Unknown] | None:
        """Return the complex conjugate of an image."""
        ...
    
    def sin(self): # -> list[Unknown] | None:
        """Return the sine of an image in degrees."""
        ...
    
    def cos(self): # -> list[Unknown] | None:
        """Return the cosine of an image in degrees."""
        ...
    
    def tan(self): # -> list[Unknown] | None:
        """Return the tangent of an image in degrees."""
        ...
    
    def asin(self): # -> list[Unknown] | None:
        """Return the inverse sine of an image in degrees."""
        ...
    
    def acos(self): # -> list[Unknown] | None:
        """Return the inverse cosine of an image in degrees."""
        ...
    
    def atan(self): # -> list[Unknown] | None:
        """Return the inverse tangent of an image in degrees."""
        ...
    
    def sinh(self): # -> list[Unknown] | None:
        """Return the hyperbolic sine of an image in radians."""
        ...
    
    def cosh(self): # -> list[Unknown] | None:
        """Return the hyperbolic cosine of an image in radians."""
        ...
    
    def tanh(self): # -> list[Unknown] | None:
        """Return the hyperbolic tangent of an image in radians."""
        ...
    
    def asinh(self): # -> list[Unknown] | None:
        """Return the inverse hyperbolic sine of an image in radians."""
        ...
    
    def acosh(self): # -> list[Unknown] | None:
        """Return the inverse hyperbolic cosine of an image in radians."""
        ...
    
    def atanh(self): # -> list[Unknown] | None:
        """Return the inverse hyperbolic tangent of an image in radians."""
        ...
    
    def log(self): # -> list[Unknown] | None:
        """Return the natural log of an image."""
        ...
    
    def log10(self): # -> list[Unknown] | None:
        """Return the log base 10 of an image."""
        ...
    
    def exp(self): # -> list[Unknown] | None:
        """Return e ** pixel."""
        ...
    
    def exp10(self): # -> list[Unknown] | None:
        """Return 10 ** pixel."""
        ...
    
    def erode(self, mask): # -> list[Unknown] | None:
        """Erode with a structuring element."""
        ...
    
    def dilate(self, mask): # -> list[Unknown] | None:
        """Dilate with a structuring element."""
        ...
    
    def median(self, size): # -> list[Unknown] | None:
        """size x size median filter."""
        ...
    
    def fliphor(self): # -> list[Unknown] | None:
        """Flip horizontally."""
        ...
    
    def flipver(self): # -> list[Unknown] | None:
        """Flip vertically."""
        ...
    
    def rot90(self): # -> list[Unknown] | None:
        """Rotate 90 degrees clockwise."""
        ...
    
    def rot180(self): # -> list[Unknown] | None:
        """Rotate 180 degrees."""
        ...
    
    def rot270(self): # -> list[Unknown] | None:
        """Rotate 270 degrees clockwise."""
        ...
    
    def hasalpha(self):
        """True if the image has an alpha channel."""
        ...
    
    def addalpha(self): # -> Self@Image | list[Unknown] | None:
        """Add an alpha channel."""
        ...
    
    @_add_doc('ifthenelse')
    def ifthenelse(self, in1, in2, **kwargs): # -> list[Unknown] | None:
        ...
    
    def scaleimage(self, **kwargs): # -> list[Unknown] | None:
        """Scale an image to 0 - 255.

        This is the libvips ``scale`` operation, renamed to avoid a clash with
        the ``scale`` for convolution masks.

        Keyword args:
            exp (float): Exponent for log scale.
            log (bool): Switch to turn on log scaling.

        Returns:
            A new :class:`Image`.

        Raises:
            :class:`.Error`

        """
        ...
    


__all__ = ['Image']
